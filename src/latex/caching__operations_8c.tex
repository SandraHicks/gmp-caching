\hypertarget{caching__operations_8c}{}\section{caching\+\_\+operations.\+c File Reference}
\label{caching__operations_8c}\index{caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}}


caching operations if numbers are large and not directly used  


{\ttfamily \#include \char`\"{}caching\+\_\+operations.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}mpz\+\_\+caching.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}hashtable.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}hashing.\+h\char`\"{}}\\*
{\ttfamily \#include $<$stdlib.\+h$>$}\\*
{\ttfamily \#include $<$stdio.\+h$>$}\\*
{\ttfamily \#include $<$inttypes.\+h$>$}\\*
Include dependency graph for caching\+\_\+operations.\+c\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{caching__operations_8c__incl}
\end{center}
\end{figure}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
uint64\+\_\+t \hyperlink{caching__operations_8c_af24ac6bfb6b961f29854a77b0fd1cdcd}{cache\+\_\+insert\+\_\+mpz\+\_\+raw} (\hyperlink{structlookup}{lookup} $\ast$lu, mpz\+\_\+t val)
\begin{DoxyCompactList}\small\item\em (for internal use only!) cache an mpz\+\_\+t \end{DoxyCompactList}\item 
uint64\+\_\+t \hyperlink{caching__operations_8c_a8378b6353d6fcf409299ae5d043405b2}{cache\+\_\+exists\+\_\+mpz\+\_\+raw} (\hyperlink{structlookup}{lookup} $\ast$lu, mpz\+\_\+t val)
\begin{DoxyCompactList}\small\item\em (for internal use only!) check if an mpz\+\_\+t already exists in cache \end{DoxyCompactList}\item 
uint64\+\_\+t \hyperlink{caching__operations_8c_a086dd00f1d95d3876f60c660c28f4655}{cache\+\_\+exists\+\_\+mpz\+\_\+binary\+\_\+raw} (\hyperlink{structlookup}{lookup} $\ast$cache, mpz\+\_\+t op1, mpz\+\_\+t op2, uint64\+\_\+t $\ast$extra\+\_\+info, int op)
\begin{DoxyCompactList}\small\item\em (for internal use only!) check if a binary operation mpz\+\_\+t x mpz\+\_\+t -\/$>$ mpt\+\_\+t exists \end{DoxyCompactList}\item 
void \hyperlink{caching__operations_8c_a9d0deb4e421d3539ca702e1d25a454bc}{init\+\_\+cache} (\hyperlink{structlookup}{lookup} $\ast$cache, uint64\+\_\+t cachesize)
\begin{DoxyCompactList}\small\item\em initialization of the lookup cache containing the hashtables and the actual cache \end{DoxyCompactList}\item 
void \hyperlink{caching__operations_8c_a5bf3baf9276c8b7f7e04b54a6d50836e}{delete\+\_\+cache} (\hyperlink{structlookup}{lookup} $\ast$cache)
\begin{DoxyCompactList}\small\item\em deletion of the cache and the underlying data structures \end{DoxyCompactList}\item 
void \hyperlink{caching__operations_8c_a14dba9d2bb5513f288c13a42127aa5d8}{get\+\_\+mpz} (\hyperlink{structlookup}{lookup} $\ast$cache, uint64\+\_\+t id, mpz\+\_\+t val)
\begin{DoxyCompactList}\small\item\em function for master cache to set a mpz\+\_\+t and get back an id \end{DoxyCompactList}\item 
double \hyperlink{caching__operations_8c_ab916e2c8a7127d6b8d2daa5723686313}{get\+\_\+double} (\hyperlink{structlookup}{lookup} $\ast$cache, uint64\+\_\+t id)
\begin{DoxyCompactList}\small\item\em function for master cache to set a mpz\+\_\+t and get back an id \end{DoxyCompactList}\item 
uint64\+\_\+t \hyperlink{caching__operations_8c_a5be5a3ac60ee70c550943ca7210ed0ad}{cache\+\_\+insert\+\_\+mpz} (\hyperlink{structlookup}{lookup} $\ast$lu, mpz\+\_\+t val)
\begin{DoxyCompactList}\small\item\em cache an mpz\+\_\+t \end{DoxyCompactList}\item 
uint64\+\_\+t \hyperlink{caching__operations_8c_a56daf76d7d1d61b8c7616dc6b4879cb4}{cache\+\_\+exists\+\_\+mpz} (\hyperlink{structlookup}{lookup} $\ast$lu, mpz\+\_\+t val)
\begin{DoxyCompactList}\small\item\em check if an mpz\+\_\+t already exists in cache \end{DoxyCompactList}\item 
uint64\+\_\+t \hyperlink{caching__operations_8c_a7c5e3db12104bd0cc6a006b02af6d68f}{cache\+\_\+exists\+\_\+mpz\+\_\+binary} (\hyperlink{structlookup}{lookup} $\ast$cache, mpz\+\_\+t op1, mpz\+\_\+t op2, uint64\+\_\+t $\ast$extra\+\_\+info, int op)
\begin{DoxyCompactList}\small\item\em check if a binary operation mpz\+\_\+t x mpz\+\_\+t -\/$>$ mpt\+\_\+t exists \end{DoxyCompactList}\item 
void \hyperlink{caching__operations_8c_a7ea00a65df3156e97a088f4609996b1f}{mpz\+\_\+swap} (mpz\+\_\+t op1, mpz\+\_\+t op2)
\begin{DoxyCompactList}\small\item\em swap two mpz\+\_\+t\textquotesingle{}s \end{DoxyCompactList}\item 
uint64\+\_\+t \hyperlink{caching__operations_8c_aa98a971c3afc7ff1d3ade18670a22042}{cached\+\_\+mpz\+\_\+add} (\hyperlink{structlookup}{lookup} $\ast$cache, mpz\+\_\+t op1\+\_\+in, mpz\+\_\+t op2\+\_\+in)
\begin{DoxyCompactList}\small\item\em addition of two mpz\+\_\+t, the operation and result are cached. \end{DoxyCompactList}\item 
uint64\+\_\+t \hyperlink{caching__operations_8c_ade2fa50c243e70384beb751d1961708a}{cached\+\_\+mpz\+\_\+sub} (\hyperlink{structlookup}{lookup} $\ast$cache, mpz\+\_\+t op1, mpz\+\_\+t op2)
\begin{DoxyCompactList}\small\item\em subtraction of two mpz\+\_\+t, the operation and result are cached. \end{DoxyCompactList}\item 
uint64\+\_\+t \hyperlink{caching__operations_8c_a745a92c531d7f1b4075fdedf31b970c4}{cached\+\_\+mpz\+\_\+mul} (\hyperlink{structlookup}{lookup} $\ast$cache, mpz\+\_\+t op1, mpz\+\_\+t op2)
\begin{DoxyCompactList}\small\item\em multiplication of two mpz\+\_\+t, the operation and result are cached. \end{DoxyCompactList}\item 
uint64\+\_\+t \hyperlink{caching__operations_8c_aa55ef35c74d3f9f270d3899adeaad0da}{cached\+\_\+mpz\+\_\+tdiv} (\hyperlink{structlookup}{lookup} $\ast$cache, uint64\+\_\+t $\ast$rest, mpz\+\_\+t op1, mpz\+\_\+t op2)
\begin{DoxyCompactList}\small\item\em integer division of two mpz\+\_\+t, the operation and result are cached. \end{DoxyCompactList}\item 
uint64\+\_\+t \hyperlink{caching__operations_8c_aeffd662de6699ec5c8f870c70ea8e612}{cached\+\_\+mpz\+\_\+mod} (\hyperlink{structlookup}{lookup} $\ast$cache, mpz\+\_\+t op1, mpz\+\_\+t op2)
\begin{DoxyCompactList}\small\item\em modulo of two mpz\+\_\+t, the operation and result are cached. \end{DoxyCompactList}\item 
uint64\+\_\+t \hyperlink{caching__operations_8c_a8ca5e7ca205dc3b211702f891d5b5f49}{cached\+\_\+mpz\+\_\+gcd} (\hyperlink{structlookup}{lookup} $\ast$cache, mpz\+\_\+t op1, mpz\+\_\+t op2)
\begin{DoxyCompactList}\small\item\em greatest common divisor of two mpz\+\_\+t, the operation and result are cached. \end{DoxyCompactList}\item 
uint64\+\_\+t \hyperlink{caching__operations_8c_a58b9d53218eca4d5c254a4500f621322}{cached\+\_\+mpz\+\_\+invert} (\hyperlink{structlookup}{lookup} $\ast$cache, mpz\+\_\+t op, mpz\+\_\+t mod)
\begin{DoxyCompactList}\small\item\em modular multiplicative inverse of op modulo mod, the operation and result are cached. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
caching operations if numbers are large and not directly used 

\begin{DoxyAuthor}{Author}
Sandra Hicks 
\end{DoxyAuthor}


\subsection{Function Documentation}
\index{caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}!cache\+\_\+exists\+\_\+mpz@{cache\+\_\+exists\+\_\+mpz}}
\index{cache\+\_\+exists\+\_\+mpz@{cache\+\_\+exists\+\_\+mpz}!caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}}
\subsubsection[{\texorpdfstring{cache\+\_\+exists\+\_\+mpz(lookup $\ast$lu, mpz\+\_\+t val)}{cache_exists_mpz(lookup *lu, mpz_t val)}}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t cache\+\_\+exists\+\_\+mpz (
\begin{DoxyParamCaption}
\item[{{\bf lookup} $\ast$}]{lu, }
\item[{mpz\+\_\+t}]{val}
\end{DoxyParamCaption}
)}\hypertarget{caching__operations_8c_a56daf76d7d1d61b8c7616dc6b4879cb4}{}\label{caching__operations_8c_a56daf76d7d1d61b8c7616dc6b4879cb4}


check if an mpz\+\_\+t already exists in cache 


\begin{DoxyParams}{Parameters}
{\em lu} & lookup cache pointer \\
\hline
{\em val} & mpz\+\_\+t which should be checked \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
id for cached mpz\+\_\+t 
\end{DoxyReturn}
\index{caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}!cache\+\_\+exists\+\_\+mpz\+\_\+binary@{cache\+\_\+exists\+\_\+mpz\+\_\+binary}}
\index{cache\+\_\+exists\+\_\+mpz\+\_\+binary@{cache\+\_\+exists\+\_\+mpz\+\_\+binary}!caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}}
\subsubsection[{\texorpdfstring{cache\+\_\+exists\+\_\+mpz\+\_\+binary(lookup $\ast$cache, mpz\+\_\+t op1, mpz\+\_\+t op2, uint64\+\_\+t $\ast$extra\+\_\+info, int op)}{cache_exists_mpz_binary(lookup *cache, mpz_t op1, mpz_t op2, uint64_t *extra_info, int op)}}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t cache\+\_\+exists\+\_\+mpz\+\_\+binary (
\begin{DoxyParamCaption}
\item[{{\bf lookup} $\ast$}]{cache, }
\item[{mpz\+\_\+t}]{op1, }
\item[{mpz\+\_\+t}]{op2, }
\item[{uint64\+\_\+t $\ast$}]{extra\+\_\+info, }
\item[{int}]{op}
\end{DoxyParamCaption}
)}\hypertarget{caching__operations_8c_a7c5e3db12104bd0cc6a006b02af6d68f}{}\label{caching__operations_8c_a7c5e3db12104bd0cc6a006b02af6d68f}


check if a binary operation mpz\+\_\+t x mpz\+\_\+t -\/$>$ mpt\+\_\+t exists 


\begin{DoxyParams}{Parameters}
{\em cache} & lookup cache pointer \\
\hline
{\em op1} & mpz\+\_\+t first operator \\
\hline
{\em op2} & mpz\+\_\+t second operator \\
\hline
{\em extra\+\_\+info} & pointer for extra information if existent (e.\+g. rest in integer division) \\
\hline
{\em op} & operator which is used \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
id for cached mpz\+\_\+t if existent, 0 if not cached 
\end{DoxyReturn}
\index{caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}!cache\+\_\+exists\+\_\+mpz\+\_\+binary\+\_\+raw@{cache\+\_\+exists\+\_\+mpz\+\_\+binary\+\_\+raw}}
\index{cache\+\_\+exists\+\_\+mpz\+\_\+binary\+\_\+raw@{cache\+\_\+exists\+\_\+mpz\+\_\+binary\+\_\+raw}!caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}}
\subsubsection[{\texorpdfstring{cache\+\_\+exists\+\_\+mpz\+\_\+binary\+\_\+raw(lookup $\ast$cache, mpz\+\_\+t op1, mpz\+\_\+t op2, uint64\+\_\+t $\ast$extra\+\_\+info, int op)}{cache_exists_mpz_binary_raw(lookup *cache, mpz_t op1, mpz_t op2, uint64_t *extra_info, int op)}}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t cache\+\_\+exists\+\_\+mpz\+\_\+binary\+\_\+raw (
\begin{DoxyParamCaption}
\item[{{\bf lookup} $\ast$}]{cache, }
\item[{mpz\+\_\+t}]{op1, }
\item[{mpz\+\_\+t}]{op2, }
\item[{uint64\+\_\+t $\ast$}]{extra\+\_\+info, }
\item[{int}]{op}
\end{DoxyParamCaption}
)}\hypertarget{caching__operations_8c_a086dd00f1d95d3876f60c660c28f4655}{}\label{caching__operations_8c_a086dd00f1d95d3876f60c660c28f4655}


(for internal use only!) check if a binary operation mpz\+\_\+t x mpz\+\_\+t -\/$>$ mpt\+\_\+t exists 


\begin{DoxyParams}{Parameters}
{\em cache} & lookup cache pointer \\
\hline
{\em op1} & mpz\+\_\+t first operator \\
\hline
{\em op2} & mpz\+\_\+t second operator \\
\hline
{\em extra\+\_\+info} & pointer for extra information if existent (e.\+g. rest in integer division) \\
\hline
{\em op} & operator which is used \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
id for cached mpz\+\_\+t if existent, 0 if not cached 
\end{DoxyReturn}
\index{caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}!cache\+\_\+exists\+\_\+mpz\+\_\+raw@{cache\+\_\+exists\+\_\+mpz\+\_\+raw}}
\index{cache\+\_\+exists\+\_\+mpz\+\_\+raw@{cache\+\_\+exists\+\_\+mpz\+\_\+raw}!caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}}
\subsubsection[{\texorpdfstring{cache\+\_\+exists\+\_\+mpz\+\_\+raw(lookup $\ast$lu, mpz\+\_\+t val)}{cache_exists_mpz_raw(lookup *lu, mpz_t val)}}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t cache\+\_\+exists\+\_\+mpz\+\_\+raw (
\begin{DoxyParamCaption}
\item[{{\bf lookup} $\ast$}]{lu, }
\item[{mpz\+\_\+t}]{val}
\end{DoxyParamCaption}
)}\hypertarget{caching__operations_8c_a8378b6353d6fcf409299ae5d043405b2}{}\label{caching__operations_8c_a8378b6353d6fcf409299ae5d043405b2}


(for internal use only!) check if an mpz\+\_\+t already exists in cache 


\begin{DoxyParams}{Parameters}
{\em lu} & lookup cache pointer \\
\hline
{\em val} & mpz\+\_\+t which should be checked \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
id for cached mpz\+\_\+t 
\end{DoxyReturn}
\index{caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}!cache\+\_\+insert\+\_\+mpz@{cache\+\_\+insert\+\_\+mpz}}
\index{cache\+\_\+insert\+\_\+mpz@{cache\+\_\+insert\+\_\+mpz}!caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}}
\subsubsection[{\texorpdfstring{cache\+\_\+insert\+\_\+mpz(lookup $\ast$lu, mpz\+\_\+t val)}{cache_insert_mpz(lookup *lu, mpz_t val)}}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t cache\+\_\+insert\+\_\+mpz (
\begin{DoxyParamCaption}
\item[{{\bf lookup} $\ast$}]{lu, }
\item[{mpz\+\_\+t}]{val}
\end{DoxyParamCaption}
)}\hypertarget{caching__operations_8c_a5be5a3ac60ee70c550943ca7210ed0ad}{}\label{caching__operations_8c_a5be5a3ac60ee70c550943ca7210ed0ad}


cache an mpz\+\_\+t 


\begin{DoxyParams}{Parameters}
{\em lu} & lookup cache pointer \\
\hline
{\em val} & mpz\+\_\+t which should be cached \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
id for cached mpz\+\_\+t 
\end{DoxyReturn}
\index{caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}!cache\+\_\+insert\+\_\+mpz\+\_\+raw@{cache\+\_\+insert\+\_\+mpz\+\_\+raw}}
\index{cache\+\_\+insert\+\_\+mpz\+\_\+raw@{cache\+\_\+insert\+\_\+mpz\+\_\+raw}!caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}}
\subsubsection[{\texorpdfstring{cache\+\_\+insert\+\_\+mpz\+\_\+raw(lookup $\ast$lu, mpz\+\_\+t val)}{cache_insert_mpz_raw(lookup *lu, mpz_t val)}}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t cache\+\_\+insert\+\_\+mpz\+\_\+raw (
\begin{DoxyParamCaption}
\item[{{\bf lookup} $\ast$}]{lu, }
\item[{mpz\+\_\+t}]{val}
\end{DoxyParamCaption}
)}\hypertarget{caching__operations_8c_af24ac6bfb6b961f29854a77b0fd1cdcd}{}\label{caching__operations_8c_af24ac6bfb6b961f29854a77b0fd1cdcd}


(for internal use only!) cache an mpz\+\_\+t 


\begin{DoxyParams}{Parameters}
{\em lu} & lookup cache pointer \\
\hline
{\em val} & mpz\+\_\+t which should be cached \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
id for cached mpz\+\_\+t 
\end{DoxyReturn}
\index{caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}!cached\+\_\+mpz\+\_\+add@{cached\+\_\+mpz\+\_\+add}}
\index{cached\+\_\+mpz\+\_\+add@{cached\+\_\+mpz\+\_\+add}!caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}}
\subsubsection[{\texorpdfstring{cached\+\_\+mpz\+\_\+add(lookup $\ast$cache, mpz\+\_\+t op1\+\_\+in, mpz\+\_\+t op2\+\_\+in)}{cached_mpz_add(lookup *cache, mpz_t op1_in, mpz_t op2_in)}}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t cached\+\_\+mpz\+\_\+add (
\begin{DoxyParamCaption}
\item[{{\bf lookup} $\ast$}]{cache, }
\item[{mpz\+\_\+t}]{op1\+\_\+in, }
\item[{mpz\+\_\+t}]{op2\+\_\+in}
\end{DoxyParamCaption}
)}\hypertarget{caching__operations_8c_aa98a971c3afc7ff1d3ade18670a22042}{}\label{caching__operations_8c_aa98a971c3afc7ff1d3ade18670a22042}


addition of two mpz\+\_\+t, the operation and result are cached. 


\begin{DoxyParams}{Parameters}
{\em cache} & lookup cache pointer \\
\hline
{\em op1\+\_\+in} & first operand \\
\hline
{\em op2\+\_\+in} & second operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
id to result of addition 
\end{DoxyReturn}
\index{caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}!cached\+\_\+mpz\+\_\+gcd@{cached\+\_\+mpz\+\_\+gcd}}
\index{cached\+\_\+mpz\+\_\+gcd@{cached\+\_\+mpz\+\_\+gcd}!caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}}
\subsubsection[{\texorpdfstring{cached\+\_\+mpz\+\_\+gcd(lookup $\ast$cache, mpz\+\_\+t op1, mpz\+\_\+t op2)}{cached_mpz_gcd(lookup *cache, mpz_t op1, mpz_t op2)}}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t cached\+\_\+mpz\+\_\+gcd (
\begin{DoxyParamCaption}
\item[{{\bf lookup} $\ast$}]{cache, }
\item[{mpz\+\_\+t}]{op1, }
\item[{mpz\+\_\+t}]{op2}
\end{DoxyParamCaption}
)}\hypertarget{caching__operations_8c_a8ca5e7ca205dc3b211702f891d5b5f49}{}\label{caching__operations_8c_a8ca5e7ca205dc3b211702f891d5b5f49}


greatest common divisor of two mpz\+\_\+t, the operation and result are cached. 


\begin{DoxyParams}{Parameters}
{\em cache} & lookup cache pointer \\
\hline
{\em op1} & first operand \\
\hline
{\em op2} & second operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
id to result of greatest common divisor 
\end{DoxyReturn}
\index{caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}!cached\+\_\+mpz\+\_\+invert@{cached\+\_\+mpz\+\_\+invert}}
\index{cached\+\_\+mpz\+\_\+invert@{cached\+\_\+mpz\+\_\+invert}!caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}}
\subsubsection[{\texorpdfstring{cached\+\_\+mpz\+\_\+invert(lookup $\ast$cache, mpz\+\_\+t op, mpz\+\_\+t mod)}{cached_mpz_invert(lookup *cache, mpz_t op, mpz_t mod)}}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t cached\+\_\+mpz\+\_\+invert (
\begin{DoxyParamCaption}
\item[{{\bf lookup} $\ast$}]{cache, }
\item[{mpz\+\_\+t}]{op, }
\item[{mpz\+\_\+t}]{mod}
\end{DoxyParamCaption}
)}\hypertarget{caching__operations_8c_a58b9d53218eca4d5c254a4500f621322}{}\label{caching__operations_8c_a58b9d53218eca4d5c254a4500f621322}


modular multiplicative inverse of op modulo mod, the operation and result are cached. 


\begin{DoxyParams}{Parameters}
{\em cache} & lookup cache pointer \\
\hline
{\em op} & first operand \\
\hline
{\em mod} & second operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
id to result of inverse, 0 if non existent 
\end{DoxyReturn}
\index{caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}!cached\+\_\+mpz\+\_\+mod@{cached\+\_\+mpz\+\_\+mod}}
\index{cached\+\_\+mpz\+\_\+mod@{cached\+\_\+mpz\+\_\+mod}!caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}}
\subsubsection[{\texorpdfstring{cached\+\_\+mpz\+\_\+mod(lookup $\ast$cache, mpz\+\_\+t op1, mpz\+\_\+t op2)}{cached_mpz_mod(lookup *cache, mpz_t op1, mpz_t op2)}}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t cached\+\_\+mpz\+\_\+mod (
\begin{DoxyParamCaption}
\item[{{\bf lookup} $\ast$}]{cache, }
\item[{mpz\+\_\+t}]{op1, }
\item[{mpz\+\_\+t}]{op2}
\end{DoxyParamCaption}
)}\hypertarget{caching__operations_8c_aeffd662de6699ec5c8f870c70ea8e612}{}\label{caching__operations_8c_aeffd662de6699ec5c8f870c70ea8e612}


modulo of two mpz\+\_\+t, the operation and result are cached. 


\begin{DoxyParams}{Parameters}
{\em cache} & lookup cache pointer \\
\hline
{\em op1} & first operand \\
\hline
{\em op2} & second operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
id to result of modulo operation 
\end{DoxyReturn}
\index{caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}!cached\+\_\+mpz\+\_\+mul@{cached\+\_\+mpz\+\_\+mul}}
\index{cached\+\_\+mpz\+\_\+mul@{cached\+\_\+mpz\+\_\+mul}!caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}}
\subsubsection[{\texorpdfstring{cached\+\_\+mpz\+\_\+mul(lookup $\ast$cache, mpz\+\_\+t op1, mpz\+\_\+t op2)}{cached_mpz_mul(lookup *cache, mpz_t op1, mpz_t op2)}}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t cached\+\_\+mpz\+\_\+mul (
\begin{DoxyParamCaption}
\item[{{\bf lookup} $\ast$}]{cache, }
\item[{mpz\+\_\+t}]{op1, }
\item[{mpz\+\_\+t}]{op2}
\end{DoxyParamCaption}
)}\hypertarget{caching__operations_8c_a745a92c531d7f1b4075fdedf31b970c4}{}\label{caching__operations_8c_a745a92c531d7f1b4075fdedf31b970c4}


multiplication of two mpz\+\_\+t, the operation and result are cached. 


\begin{DoxyParams}{Parameters}
{\em cache} & lookup cache pointer \\
\hline
{\em op1} & first operand \\
\hline
{\em op2} & second operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
id to result of multiplication 
\end{DoxyReturn}
\index{caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}!cached\+\_\+mpz\+\_\+sub@{cached\+\_\+mpz\+\_\+sub}}
\index{cached\+\_\+mpz\+\_\+sub@{cached\+\_\+mpz\+\_\+sub}!caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}}
\subsubsection[{\texorpdfstring{cached\+\_\+mpz\+\_\+sub(lookup $\ast$cache, mpz\+\_\+t op1, mpz\+\_\+t op2)}{cached_mpz_sub(lookup *cache, mpz_t op1, mpz_t op2)}}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t cached\+\_\+mpz\+\_\+sub (
\begin{DoxyParamCaption}
\item[{{\bf lookup} $\ast$}]{cache, }
\item[{mpz\+\_\+t}]{op1, }
\item[{mpz\+\_\+t}]{op2}
\end{DoxyParamCaption}
)}\hypertarget{caching__operations_8c_ade2fa50c243e70384beb751d1961708a}{}\label{caching__operations_8c_ade2fa50c243e70384beb751d1961708a}


subtraction of two mpz\+\_\+t, the operation and result are cached. 


\begin{DoxyParams}{Parameters}
{\em cache} & lookup cache pointer \\
\hline
{\em op1} & first operand \\
\hline
{\em op2} & second operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
id to result of subtraction 
\end{DoxyReturn}
\index{caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}!cached\+\_\+mpz\+\_\+tdiv@{cached\+\_\+mpz\+\_\+tdiv}}
\index{cached\+\_\+mpz\+\_\+tdiv@{cached\+\_\+mpz\+\_\+tdiv}!caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}}
\subsubsection[{\texorpdfstring{cached\+\_\+mpz\+\_\+tdiv(lookup $\ast$cache, uint64\+\_\+t $\ast$rest, mpz\+\_\+t op1, mpz\+\_\+t op2)}{cached_mpz_tdiv(lookup *cache, uint64_t *rest, mpz_t op1, mpz_t op2)}}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t cached\+\_\+mpz\+\_\+tdiv (
\begin{DoxyParamCaption}
\item[{{\bf lookup} $\ast$}]{cache, }
\item[{uint64\+\_\+t $\ast$}]{rest, }
\item[{mpz\+\_\+t}]{op1, }
\item[{mpz\+\_\+t}]{op2}
\end{DoxyParamCaption}
)}\hypertarget{caching__operations_8c_aa55ef35c74d3f9f270d3899adeaad0da}{}\label{caching__operations_8c_aa55ef35c74d3f9f270d3899adeaad0da}


integer division of two mpz\+\_\+t, the operation and result are cached. 


\begin{DoxyParams}{Parameters}
{\em cache} & lookup cache pointer \\
\hline
{\em rest} & pointer to store the rest of the integer division \\
\hline
{\em op1} & first operand \\
\hline
{\em op2} & second operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
id to result of division 
\end{DoxyReturn}
\index{caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}!delete\+\_\+cache@{delete\+\_\+cache}}
\index{delete\+\_\+cache@{delete\+\_\+cache}!caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}}
\subsubsection[{\texorpdfstring{delete\+\_\+cache(lookup $\ast$cache)}{delete_cache(lookup *cache)}}]{\setlength{\rightskip}{0pt plus 5cm}void delete\+\_\+cache (
\begin{DoxyParamCaption}
\item[{{\bf lookup} $\ast$}]{cache}
\end{DoxyParamCaption}
)}\hypertarget{caching__operations_8c_a5bf3baf9276c8b7f7e04b54a6d50836e}{}\label{caching__operations_8c_a5bf3baf9276c8b7f7e04b54a6d50836e}


deletion of the cache and the underlying data structures 


\begin{DoxyParams}{Parameters}
{\em cache} & lookup cache pointer \\
\hline
\end{DoxyParams}
\index{caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}!get\+\_\+double@{get\+\_\+double}}
\index{get\+\_\+double@{get\+\_\+double}!caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}}
\subsubsection[{\texorpdfstring{get\+\_\+double(lookup $\ast$cache, uint64\+\_\+t id)}{get_double(lookup *cache, uint64_t id)}}]{\setlength{\rightskip}{0pt plus 5cm}double get\+\_\+double (
\begin{DoxyParamCaption}
\item[{{\bf lookup} $\ast$}]{cache, }
\item[{uint64\+\_\+t}]{id}
\end{DoxyParamCaption}
)}\hypertarget{caching__operations_8c_ab916e2c8a7127d6b8d2daa5723686313}{}\label{caching__operations_8c_ab916e2c8a7127d6b8d2daa5723686313}


function for master cache to set a mpz\+\_\+t and get back an id 


\begin{DoxyParams}{Parameters}
{\em cache} & lookup cache pointer \\
\hline
{\em id} & for cached mpz\+\_\+t \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
double representation for mpz\+\_\+t 
\end{DoxyReturn}
\index{caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}!get\+\_\+mpz@{get\+\_\+mpz}}
\index{get\+\_\+mpz@{get\+\_\+mpz}!caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}}
\subsubsection[{\texorpdfstring{get\+\_\+mpz(lookup $\ast$cache, uint64\+\_\+t id, mpz\+\_\+t val)}{get_mpz(lookup *cache, uint64_t id, mpz_t val)}}]{\setlength{\rightskip}{0pt plus 5cm}void get\+\_\+mpz (
\begin{DoxyParamCaption}
\item[{{\bf lookup} $\ast$}]{cache, }
\item[{uint64\+\_\+t}]{id, }
\item[{mpz\+\_\+t}]{val}
\end{DoxyParamCaption}
)}\hypertarget{caching__operations_8c_a14dba9d2bb5513f288c13a42127aa5d8}{}\label{caching__operations_8c_a14dba9d2bb5513f288c13a42127aa5d8}


function for master cache to set a mpz\+\_\+t and get back an id 


\begin{DoxyParams}{Parameters}
{\em cache} & lookup cache pointer \\
\hline
{\em id} & id for cached mpz\+\_\+t \\
\hline
{\em val} & for writing the result \\
\hline
\end{DoxyParams}
\index{caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}!init\+\_\+cache@{init\+\_\+cache}}
\index{init\+\_\+cache@{init\+\_\+cache}!caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}}
\subsubsection[{\texorpdfstring{init\+\_\+cache(lookup $\ast$cache, uint64\+\_\+t cachesize)}{init_cache(lookup *cache, uint64_t cachesize)}}]{\setlength{\rightskip}{0pt plus 5cm}void init\+\_\+cache (
\begin{DoxyParamCaption}
\item[{{\bf lookup} $\ast$}]{cache, }
\item[{uint64\+\_\+t}]{cachesize}
\end{DoxyParamCaption}
)}\hypertarget{caching__operations_8c_a9d0deb4e421d3539ca702e1d25a454bc}{}\label{caching__operations_8c_a9d0deb4e421d3539ca702e1d25a454bc}


initialization of the lookup cache containing the hashtables and the actual cache 


\begin{DoxyParams}{Parameters}
{\em cache} & lookup cache pointer \\
\hline
{\em cachesize} & size of the cache \\
\hline
\end{DoxyParams}
\index{caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}!mpz\+\_\+swap@{mpz\+\_\+swap}}
\index{mpz\+\_\+swap@{mpz\+\_\+swap}!caching\+\_\+operations.\+c@{caching\+\_\+operations.\+c}}
\subsubsection[{\texorpdfstring{mpz\+\_\+swap(mpz\+\_\+t op1, mpz\+\_\+t op2)}{mpz_swap(mpz_t op1, mpz_t op2)}}]{\setlength{\rightskip}{0pt plus 5cm}void mpz\+\_\+swap (
\begin{DoxyParamCaption}
\item[{mpz\+\_\+t}]{op1, }
\item[{mpz\+\_\+t}]{op2}
\end{DoxyParamCaption}
)}\hypertarget{caching__operations_8c_a7ea00a65df3156e97a088f4609996b1f}{}\label{caching__operations_8c_a7ea00a65df3156e97a088f4609996b1f}


swap two mpz\+\_\+t\textquotesingle{}s 


\begin{DoxyParams}{Parameters}
{\em op1} & \\
\hline
{\em op2} & \\
\hline
\end{DoxyParams}
